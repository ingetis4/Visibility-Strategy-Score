{"ast":null,"code":"/**\n * Utilitaire pour faire des requêtes fetch avec retry automatique\n * Gère les erreurs réseau, CORS, et timeouts\n */\n\n/**\n * Fait une requête fetch avec retry automatique\n * @param {string} url - URL de l'API\n * @param {object} options - Options de fetch (method, headers, body, etc.)\n * @param {object} retryOptions - Options de retry (maxRetries, delay, backoff)\n * @returns {Promise<Response>}\n */\nasync function fetchWithRetry(url, options = {}, retryOptions = {}) {\n  const {\n    maxRetries = 3,\n    delay = 1000,\n    backoff = 2,\n    // Multiplicateur pour le délai entre chaque retry\n    retryableStatuses = [408, 429, 500, 502, 503, 504],\n    // Statuts HTTP qui justifient un retry\n    retryableErrors = ['NetworkError', 'Failed to fetch', 'TypeError'] // Types d'erreurs qui justifient un retry\n  } = retryOptions;\n  let lastError;\n  let currentDelay = delay;\n  for (let attempt = 0; attempt <= maxRetries; attempt++) {\n    try {\n      const controller = new AbortController();\n      const timeoutId = setTimeout(() => controller.abort(), 30000); // 30s timeout\n\n      const response = await fetch(url, {\n        ...options,\n        signal: controller.signal\n      });\n      clearTimeout(timeoutId);\n\n      // Si la réponse est OK, la retourner\n      if (response.ok) {\n        return response;\n      }\n\n      // Si le statut est retryable et qu'il reste des tentatives\n      if (retryableStatuses.includes(response.status) && attempt < maxRetries) {\n        console.warn(`[RETRY] Tentative ${attempt + 1}/${maxRetries + 1} - Statut ${response.status}, retry dans ${currentDelay}ms`);\n        await new Promise(resolve => setTimeout(resolve, currentDelay));\n        currentDelay *= backoff;\n        continue;\n      }\n\n      // Si le statut n'est pas retryable ou qu'on a épuisé les tentatives, retourner la réponse\n      return response;\n    } catch (error) {\n      lastError = error;\n\n      // Vérifier si l'erreur est retryable\n      const isRetryable = retryableErrors.some(errType => error.name === errType || error.message.includes(errType) || error.message.includes('network') || error.message.includes('fetch'));\n\n      // Si l'erreur n'est pas retryable ou qu'on a épuisé les tentatives, throw\n      if (!isRetryable || attempt >= maxRetries) {\n        throw error;\n      }\n      console.warn(`[RETRY] Tentative ${attempt + 1}/${maxRetries + 1} - Erreur: ${error.message}, retry dans ${currentDelay}ms`);\n      await new Promise(resolve => setTimeout(resolve, currentDelay));\n      currentDelay *= backoff;\n    }\n  }\n\n  // Si on arrive ici, toutes les tentatives ont échoué\n  throw lastError || new Error('Toutes les tentatives ont échoué');\n}\nexport default fetchWithRetry;","map":{"version":3,"names":["fetchWithRetry","url","options","retryOptions","maxRetries","delay","backoff","retryableStatuses","retryableErrors","lastError","currentDelay","attempt","controller","AbortController","timeoutId","setTimeout","abort","response","fetch","signal","clearTimeout","ok","includes","status","console","warn","Promise","resolve","error","isRetryable","some","errType","name","message","Error"],"sources":["/Users/ares/DEV/Visibility strategy score/frontend/src/utils/fetchWithRetry.js"],"sourcesContent":["/**\n * Utilitaire pour faire des requêtes fetch avec retry automatique\n * Gère les erreurs réseau, CORS, et timeouts\n */\n\n/**\n * Fait une requête fetch avec retry automatique\n * @param {string} url - URL de l'API\n * @param {object} options - Options de fetch (method, headers, body, etc.)\n * @param {object} retryOptions - Options de retry (maxRetries, delay, backoff)\n * @returns {Promise<Response>}\n */\nasync function fetchWithRetry(url, options = {}, retryOptions = {}) {\n  const {\n    maxRetries = 3,\n    delay = 1000,\n    backoff = 2, // Multiplicateur pour le délai entre chaque retry\n    retryableStatuses = [408, 429, 500, 502, 503, 504], // Statuts HTTP qui justifient un retry\n    retryableErrors = ['NetworkError', 'Failed to fetch', 'TypeError'] // Types d'erreurs qui justifient un retry\n  } = retryOptions;\n\n  let lastError;\n  let currentDelay = delay;\n\n  for (let attempt = 0; attempt <= maxRetries; attempt++) {\n    try {\n      const controller = new AbortController();\n      const timeoutId = setTimeout(() => controller.abort(), 30000); // 30s timeout\n\n      const response = await fetch(url, {\n        ...options,\n        signal: controller.signal\n      });\n\n      clearTimeout(timeoutId);\n\n      // Si la réponse est OK, la retourner\n      if (response.ok) {\n        return response;\n      }\n\n      // Si le statut est retryable et qu'il reste des tentatives\n      if (retryableStatuses.includes(response.status) && attempt < maxRetries) {\n        console.warn(`[RETRY] Tentative ${attempt + 1}/${maxRetries + 1} - Statut ${response.status}, retry dans ${currentDelay}ms`);\n        await new Promise(resolve => setTimeout(resolve, currentDelay));\n        currentDelay *= backoff;\n        continue;\n      }\n\n      // Si le statut n'est pas retryable ou qu'on a épuisé les tentatives, retourner la réponse\n      return response;\n\n    } catch (error) {\n      lastError = error;\n      \n      // Vérifier si l'erreur est retryable\n      const isRetryable = retryableErrors.some(errType => \n        error.name === errType || \n        error.message.includes(errType) ||\n        error.message.includes('network') ||\n        error.message.includes('fetch')\n      );\n\n      // Si l'erreur n'est pas retryable ou qu'on a épuisé les tentatives, throw\n      if (!isRetryable || attempt >= maxRetries) {\n        throw error;\n      }\n\n      console.warn(`[RETRY] Tentative ${attempt + 1}/${maxRetries + 1} - Erreur: ${error.message}, retry dans ${currentDelay}ms`);\n      await new Promise(resolve => setTimeout(resolve, currentDelay));\n      currentDelay *= backoff;\n    }\n  }\n\n  // Si on arrive ici, toutes les tentatives ont échoué\n  throw lastError || new Error('Toutes les tentatives ont échoué');\n}\n\nexport default fetchWithRetry;\n\n"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAeA,cAAcA,CAACC,GAAG,EAAEC,OAAO,GAAG,CAAC,CAAC,EAAEC,YAAY,GAAG,CAAC,CAAC,EAAE;EAClE,MAAM;IACJC,UAAU,GAAG,CAAC;IACdC,KAAK,GAAG,IAAI;IACZC,OAAO,GAAG,CAAC;IAAE;IACbC,iBAAiB,GAAG,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC;IAAE;IACpDC,eAAe,GAAG,CAAC,cAAc,EAAE,iBAAiB,EAAE,WAAW,CAAC,CAAC;EACrE,CAAC,GAAGL,YAAY;EAEhB,IAAIM,SAAS;EACb,IAAIC,YAAY,GAAGL,KAAK;EAExB,KAAK,IAAIM,OAAO,GAAG,CAAC,EAAEA,OAAO,IAAIP,UAAU,EAAEO,OAAO,EAAE,EAAE;IACtD,IAAI;MACF,MAAMC,UAAU,GAAG,IAAIC,eAAe,CAAC,CAAC;MACxC,MAAMC,SAAS,GAAGC,UAAU,CAAC,MAAMH,UAAU,CAACI,KAAK,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC,CAAC;;MAE/D,MAAMC,QAAQ,GAAG,MAAMC,KAAK,CAACjB,GAAG,EAAE;QAChC,GAAGC,OAAO;QACViB,MAAM,EAAEP,UAAU,CAACO;MACrB,CAAC,CAAC;MAEFC,YAAY,CAACN,SAAS,CAAC;;MAEvB;MACA,IAAIG,QAAQ,CAACI,EAAE,EAAE;QACf,OAAOJ,QAAQ;MACjB;;MAEA;MACA,IAAIV,iBAAiB,CAACe,QAAQ,CAACL,QAAQ,CAACM,MAAM,CAAC,IAAIZ,OAAO,GAAGP,UAAU,EAAE;QACvEoB,OAAO,CAACC,IAAI,CAAC,qBAAqBd,OAAO,GAAG,CAAC,IAAIP,UAAU,GAAG,CAAC,aAAaa,QAAQ,CAACM,MAAM,gBAAgBb,YAAY,IAAI,CAAC;QAC5H,MAAM,IAAIgB,OAAO,CAACC,OAAO,IAAIZ,UAAU,CAACY,OAAO,EAAEjB,YAAY,CAAC,CAAC;QAC/DA,YAAY,IAAIJ,OAAO;QACvB;MACF;;MAEA;MACA,OAAOW,QAAQ;IAEjB,CAAC,CAAC,OAAOW,KAAK,EAAE;MACdnB,SAAS,GAAGmB,KAAK;;MAEjB;MACA,MAAMC,WAAW,GAAGrB,eAAe,CAACsB,IAAI,CAACC,OAAO,IAC9CH,KAAK,CAACI,IAAI,KAAKD,OAAO,IACtBH,KAAK,CAACK,OAAO,CAACX,QAAQ,CAACS,OAAO,CAAC,IAC/BH,KAAK,CAACK,OAAO,CAACX,QAAQ,CAAC,SAAS,CAAC,IACjCM,KAAK,CAACK,OAAO,CAACX,QAAQ,CAAC,OAAO,CAChC,CAAC;;MAED;MACA,IAAI,CAACO,WAAW,IAAIlB,OAAO,IAAIP,UAAU,EAAE;QACzC,MAAMwB,KAAK;MACb;MAEAJ,OAAO,CAACC,IAAI,CAAC,qBAAqBd,OAAO,GAAG,CAAC,IAAIP,UAAU,GAAG,CAAC,cAAcwB,KAAK,CAACK,OAAO,gBAAgBvB,YAAY,IAAI,CAAC;MAC3H,MAAM,IAAIgB,OAAO,CAACC,OAAO,IAAIZ,UAAU,CAACY,OAAO,EAAEjB,YAAY,CAAC,CAAC;MAC/DA,YAAY,IAAIJ,OAAO;IACzB;EACF;;EAEA;EACA,MAAMG,SAAS,IAAI,IAAIyB,KAAK,CAAC,kCAAkC,CAAC;AAClE;AAEA,eAAelC,cAAc","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}